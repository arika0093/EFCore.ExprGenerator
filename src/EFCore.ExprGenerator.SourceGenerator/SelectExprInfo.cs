using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EFCore.ExprGenerator;

/// <summary>
/// Base record for SelectExpr information
/// </summary>
internal abstract record SelectExprInfo
{
    public required ITypeSymbol SourceType { get; init; }
    public required SemanticModel SemanticModel { get; init; }
    public required InvocationExpressionSyntax Invocation { get; init; }

    // Generate DTO structure for unique ID generation
    public abstract DtoStructure GenerateDtoStructure();

    // Get DTO class name
    public abstract string GetClassName(DtoStructure structure);

    // Generate DTO classes
    public string GenerateDtoClasses(
        DtoStructure structure,
        List<string> dtoClasses,
        string namespaceName
    )
    {
        var dtoName = GetClassName(structure);

        var sb = new StringBuilder();
        sb.AppendLine($"public class {dtoName}");
        sb.AppendLine("{");

        foreach (var prop in structure.Properties)
        {
            var propertyType = prop.TypeName;
            // If propertyType is a generic type, use only the base type
            if (propertyType.Contains("<"))
            {
                propertyType = propertyType[..propertyType.IndexOf("<")];
            }

            // For nested structures, recursively generate DTOs (add first)
            if (prop.NestedStructure is not null)
            {
                var nestedId = prop.NestedStructure.GetUniqueId();
                var nestedDtoName = GenerateDtoClasses(
                    prop.NestedStructure,
                    dtoClasses,
                    namespaceName
                );
                // Since propertyType already has a fully qualified name starting with global::,
                // add global:: to nestedDtoName as well
                var nestedDtoFullName = $"global::{namespaceName}.{nestedDtoName}";
                propertyType = $"{propertyType}<{nestedDtoFullName}>";
            }
            sb.AppendLine($"    public required {propertyType} {prop.Name} {{ get; set; }}");
        }

        sb.AppendLine("}");

        // Add current DTO (nested DTOs are already added by recursive calls)
        dtoClasses.Add(sb.ToString());
        return dtoName;
    }

    // Generate source code
    public void GenerateCode(SourceProductionContext context)
    {
        try
        {
            // Analyze anonymous type structure
            var dtoStructure = GenerateDtoStructure();

            // Skip if properties are empty
            if (dtoStructure.Properties.Count == 0)
                return;

            // Generate unique ID (from hash of property structure)
            var uniqueId = GetUniqueId();

            // Get namespace
            var namespaceSymbol = SourceType.ContainingNamespace;
            var namespaceName = namespaceSymbol?.ToDisplayString() ?? "Generated";

            // Generate DTO classes (including nested DTOs)
            var dtoClasses = new List<string>();
            var mainDtoName = GenerateDtoClasses(dtoStructure, dtoClasses, namespaceName);
            var mainDtoFullName = $"global::{namespaceName}.{mainDtoName}";

            // Generate SelectExpr method
            var selectExprMethod = GenerateSelectExprMethod(mainDtoFullName, dtoStructure);

            // Build final source code
            var sourceCode = BuildSourceCode(
                namespaceName,
                mainDtoName,
                dtoClasses,
                selectExprMethod
            );

            // Register with Source Generator
            context.AddSource($"GeneratedExpression_{uniqueId}.g.cs", sourceCode);
        }
        catch (Exception ex)
        {
            // Output error information for debugging
            var errorMessage = $"""
                // Source Generator Error: {ex.Message}
                // Stack Trace: {ex.StackTrace}
                """;
            context.AddSource("GeneratorError.g.cs", errorMessage);
        }
    }

    // Generate unique ID
    public string GetUniqueId() => GenerateDtoStructure().GetUniqueId();

    protected string BuildSourceCode(
        string namespaceName,
        string mainDtoName,
        List<string> dtoClasses,
        string selectExprMethod
    )
    {
        var sb = new StringBuilder();
        sb.Append(
            $$"""
            // <auto-generated />
            #nullable enable
            #pragma warning disable IDE0060
            #pragma warning disable CS8601

            using System;
            using System.Linq;
            using System.Collections.Generic;

            namespace {{namespaceName}};
            internal static partial class GeneratedExpression_{{mainDtoName}}
            {
            {{selectExprMethod}}
            }
            """
        );
        sb.AppendLine();
        foreach (var dtoClass in dtoClasses)
        {
            sb.AppendLine(dtoClass);
        }
        return sb.ToString();
    }

    protected string GenerateSelectExprMethod(string dtoName, DtoStructure structure)
    {
        var sourceTypeFullName = structure.SourceTypeFullName;
        var sb = new StringBuilder();
        sb.AppendLine(
            $$""""
                /// <summary>
                /// generated select expression method of {{dtoName}}
                /// </summary>
                [System.Runtime.CompilerServices.OverloadResolutionPriority(1)]
                public static IQueryable<{{dtoName}}> SelectExpr<TResult>(
                    this IQueryable<{{sourceTypeFullName}}> query,
                    Func<{{sourceTypeFullName}}, TResult> selector)
                {
                    return query.Select(s => new {{dtoName}}
                    {
            """"
        );
        // Generate property assignments
        var propertyAssignments = structure
            .Properties.Select(prop =>
            {
                var assignment = GeneratePropertyAssignment(prop);
                return $"            {prop.Name} = {assignment}";
            })
            .ToList();
        sb.AppendLine(string.Join($",\n", propertyAssignments));
        sb.AppendLine("        });");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    protected string GeneratePropertyAssignment(DtoProperty property)
    {
        var expression = property.OriginalExpression;
        // For nested Select (collection) case
        if (property.NestedStructure is not null)
        {
            var converted = ConvertNestedSelect(expression, property.NestedStructure);
            // Debug: Check if conversion was performed correctly
            if (converted == expression && expression.Contains("Select"))
            {
                // If conversion was not performed, leave the original expression as a comment
                return $"{converted} /* CONVERSION FAILED: {property.Name} */";
            }
            return converted;
        }
        // If nullable operator is used, convert to explicit null check
        if (property.IsNullable && expression.Contains("?."))
        {
            return ConvertNullableAccessToExplicitCheck(expression);
        }
        // Regular property access
        return expression;
    }

    protected string ConvertNestedSelect(string expression, DtoStructure nestedStructure)
    {
        // Example: s.Childs.Select(c => new { ... })
        // Extract parameter name (e.g., "c")
        // Consider the possibility of whitespace or generic type parameters after .Select
        var selectIndex = expression.IndexOf(".Select");
        if (selectIndex == -1)
            return expression;
        // Find '(' after Select (start of lambda)
        var lambdaStart = expression.IndexOf("(", selectIndex);
        if (lambdaStart == -1)
            return expression;
        var lambdaArrow = expression.IndexOf("=>", lambdaStart);
        if (lambdaArrow == -1 || lambdaArrow <= lambdaStart + 1)
            return expression;
        var paramName = expression.Substring(lambdaStart + 1, lambdaArrow - lambdaStart - 1).Trim();
        if (string.IsNullOrEmpty(paramName))
            paramName = "x"; // Default parameter name
        var baseExpression = expression[..selectIndex];
        var nestedDtoName = GetClassName(nestedStructure);
        var propertyAssignments = new List<string>();
        foreach (var prop in nestedStructure.Properties)
        {
            var assignment = GeneratePropertyAssignment(prop);
            // For nested Select, convert to inline to avoid multi-line
            assignment = assignment.Replace("\n", " ").Replace("\r", "");
            propertyAssignments.Add($"{prop.Name} = {assignment}");
        }
        var propertiesCode = string.Join(", ", propertyAssignments);
        return $"{baseExpression}.Select({paramName} => new {nestedDtoName} {{ {propertiesCode} }})";
    }

    protected string ConvertNullableAccessToExplicitCheck(string expression)
    {
        // Example: c.Child?.Id → c.Child != null ? c.Child.Id : null
        // Example: s.Child3?.Child?.Id → s.Child3 != null && s.Child3.Child != null ? s.Child3.Child.Id : null
        if (!expression.Contains("?."))
            return expression;
        // Replace ?. with . to create the actual access path
        var accessPath = expression.Replace("?.", ".");
        // Find where ?. occurs and build null checks
        var checks = new List<string>();
        var parts = expression.Split(["?."], StringSplitOptions.None);
        if (parts.Length < 2)
            return expression;
        // All parts except the first require null checks
        var currentPath = parts[0];
        for (int i = 1; i < parts.Length; i++)
        {
            checks.Add($"{currentPath} != null");
            // Get the first token (property name) of the next part
            var nextPart = parts[i];
            var dotIndex = nextPart.IndexOf('.');
            var propertyName = dotIndex > 0 ? nextPart[..dotIndex] : nextPart;
            currentPath = $"{currentPath}.{propertyName}";
        }
        if (checks.Count == 0)
            return expression;
        // Build null checks
        var nullCheckPart = string.Join(" && ", checks);
        return $"{nullCheckPart} ? {accessPath} : default";
    }

    protected string? GetImplicitPropertyName(ExpressionSyntax expression)
    {
        // Get property name from member access (e.g., s.Id)
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            return memberAccess.Name.Identifier.Text;
        }

        // Get property name from identifier (e.g., id)
        if (expression is IdentifierNameSyntax identifier)
        {
            return identifier.Identifier.Text;
        }

        // Do not process other complex expressions
        return null;
    }
}
