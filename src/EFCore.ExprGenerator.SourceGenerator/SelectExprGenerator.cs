using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EFCore.ExprGenerator;

/// <summary>
/// Generator for SelectExpr method
/// </summary>
[Generator]
public partial class SelectExprGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initialize the generator
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate InterceptsLocationAttribute for the consuming project
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                "InterceptsLocationAttribute.g.cs",
                """
                // <auto-generated />
                #nullable enable
                namespace System.Runtime.CompilerServices
                {
                    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                    internal sealed class InterceptsLocationAttribute : Attribute
                    {
                        public InterceptsLocationAttribute(int version, string data)
                        {
                            Version = version;
                            Data = data;
                        }

                        public int Version { get; }
                        public string Data { get; }
                    }
                }
                """
            );
        });

        // Provider to detect SelectExpr method invocations
        var invocations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => IsSelectExprInvocation(node),
                transform: static (ctx, _) => GetSelectExprInfo(ctx)
            )
            .Where(static info => info is not null)
            .Collect();

        // Code generation
        context.RegisterSourceOutput(
            invocations,
            (spc, infos) =>
            {
                // Separate explicit DTO infos from others
                var explicitDtoInfos = new List<SelectExprInfoExplicitDto>();
                var otherInfos = new List<SelectExprInfo>();

                foreach (var info in infos)
                {
                    if (info is null)
                        continue;

                    if (info is SelectExprInfoExplicitDto explicitInfo)
                    {
                        explicitDtoInfos.Add(explicitInfo);
                    }
                    else
                    {
                        otherInfos.Add(info);
                    }
                }

                // Group explicit DTO infos by namespace + DTO name + structure
                var explicitDtoGroups = new Dictionary<string, SelectExprInfoExplicitDto>();
                foreach (var info in explicitDtoInfos)
                {
                    var structureHash = info.GenerateDtoStructure().GetUniqueId();
                    var groupKey = $"{info.TargetNamespace}|{info.ExplicitDtoName}|{structureHash}";

                    if (explicitDtoGroups.TryGetValue(groupKey, out var existing))
                    {
                        // Add this location to the existing info
                        var location = info.SemanticModel.GetInterceptableLocation(info.Invocation);
                        if (location is not null && !existing.Locations.Contains(location))
                        {
                            existing.Locations.Add(location);
                        }
                    }
                    else
                    {
                        explicitDtoGroups.Add(groupKey, info);
                    }
                }

                // Generate code for explicit DTO infos (one method per group)
                foreach (var kvp in explicitDtoGroups)
                {
                    var info = kvp.Value;
                    info.GenerateCode(spc);
                }

                // Group other infos by DTO structure (traditional behavior)
                var dict = new Dictionary<string, SelectExprInfo>();
                foreach (var info in otherInfos)
                {
                    var structureId = info.GetUniqueId();
                    if (!dict.ContainsKey(structureId))
                    {
                        dict.Add(structureId, info);
                    }
                    else
                    {
                        // export error file
                        spc.AddSource(
                            $"Error_SelectExpr_Duplicate_{structureId}.g.cs",
                            $"""
                            // Error: Duplicate SelectExpr invocation with identical DTO structure detected.
                            // This may cause conflicts in generated method names.
                            // Please ensure that each SelectExpr usage has a unique DTO structure.
                            """
                        );
                    }
                }

                // Generate code for each unique structure (traditional behavior)
                foreach (var kvp in dict)
                {
                    var info = kvp.Value;
                    info.GenerateCode(spc);
                }
            }
        );
    }

    private static bool IsSelectExprInvocation(SyntaxNode node)
    {
        // Detect InvocationExpression with method name "SelectExpr"
        if (node is not InvocationExpressionSyntax invocation)
            return false;

        var expression = invocation.Expression;

        // MemberAccessExpression (e.g., query.SelectExpr)
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            return memberAccess.Name.Identifier.Text == "SelectExpr";
        }

        return false;
    }

    private static SelectExprInfo? GetSelectExprInfo(GeneratorSyntaxContext context)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        // Get lambda expression from arguments
        if (invocation.ArgumentList.Arguments.Count == 0)
            return null;

        var lambdaArg = invocation.ArgumentList.Arguments[0].Expression;
        if (lambdaArg is not LambdaExpressionSyntax lambda)
            return null;

        // Check if this is a generic invocation with explicit type arguments
        // SelectExpr<TIn, TResult> form
        if (
            invocation.Expression is MemberAccessExpressionSyntax memberAccess
            && memberAccess.Name is GenericNameSyntax genericName
            && genericName.TypeArgumentList.Arguments.Count == 2
        )
        {
            // This is the new SelectExpr<TIn, TResult> form
            if (lambda.Body is AnonymousObjectCreationExpressionSyntax anon)
            {
                return GetExplicitDtoSelectExprInfo(context, anon, genericName);
            }
        }

        // Check if lambda body is an object initializer
        var body = lambda.Body;
        switch (body)
        {
            case AnonymousObjectCreationExpressionSyntax anon:
                return GetAnonymousSelectExprInfo(context, anon);
            case ObjectCreationExpressionSyntax objCreation:
                return GetNamedSelectExprInfo(context, objCreation);
            default:
                return null;
        }
    }

    private static SelectExprInfoAnonymous? GetAnonymousSelectExprInfo(
        GeneratorSyntaxContext context,
        AnonymousObjectCreationExpressionSyntax anonymousObj
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get T from IQueryable<T>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        return new SelectExprInfoAnonymous
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
        };
    }

    private static SelectExprInfoNamed? GetNamedSelectExprInfo(
        GeneratorSyntaxContext context,
        ObjectCreationExpressionSyntax obj
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get T from IQueryable<T>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        return new SelectExprInfoNamed
        {
            SourceType = sourceType,
            ObjectCreation = obj,
            SemanticModel = semanticModel,
            Invocation = invocation,
        };
    }

    private static SelectExprInfoExplicitDto? GetExplicitDtoSelectExprInfo(
        GeneratorSyntaxContext context,
        AnonymousObjectCreationExpressionSyntax anonymousObj,
        GenericNameSyntax genericName
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get TIn from IQueryable<TIn>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        // Get TResult (second type parameter) - this is the explicit DTO name
        var typeArguments = genericName.TypeArgumentList.Arguments;
        if (typeArguments.Count != 2)
            return null;

        var tResultType = semanticModel.GetTypeInfo(typeArguments[1]).Type;
        if (tResultType is null)
            return null;

        var explicitDtoName = tResultType.Name;

        // Get the namespace of the calling code
        var invocationSyntaxTree = invocation.SyntaxTree;
        var root = invocationSyntaxTree.GetRoot();
        var namespaceDecl = invocation
            .Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        var targetNamespace =
            namespaceDecl?.Name.ToString() ?? semanticModel.Compilation.AssemblyName ?? "Generated";

        return new SelectExprInfoExplicitDto
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            ExplicitDtoName = explicitDtoName,
            TargetNamespace = targetNamespace,
        };
    }
}
